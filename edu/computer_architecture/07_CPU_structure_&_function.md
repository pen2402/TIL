# CPU 구조와 기능

## CPU의 기본 구조

### 산술 논리 장치(ALU, Arithmetic and Logical Unit)

- 산술 연산과 논리 연산을 수행하는 장치
- 기본 연산 기능
  - 이진 가감산
  - 논리 연산
  - 보수 연산
  - 시프트 연산

### 제어 장치(CU, Control Unit)

- 프로그램 코드를 해석하고 이를 실행하기 위한 제어 신호들을 순차적으로 발생하는 하드웨어 모듈
- CPU 내부 버스를 제어하고 연산에 필요한 동작 신호를 ALU와 레지스터 장치에 보냄
- CPU 외부의 메모리나 I/O 버스에 읽기 신호와 쓰기 신호를 보냄

### 레지스터 세트

- CPU 내부에 있는 소규모의 일시적인 기억장치
- 사용 용도에 따른 레지스터
  - 누산기 레지스터(AC, Accumulator Register)
    - CPU 내의 계산된 중간 결과를 저장하는 레지스터
  - 범용 레지스터(GR, General Register)
    - 산술 및 논리 연산, 연산 결과의 임시 저장, 주소 색인 등 여러 목적으로 사용되는 레지스터
  - 프로그램 카운터(PC, Program Counter)
    - 명령어 포인터(IP, Instruction Pointer)라고도 함
    - 다음에 수행될 명령어의 주소를 일시적으로 저장하는 레지스터
    - 명령을 가져오면 카운터의 값이 증가
  - 명령 레지스터(IR, Instruction Register)
    - 실행될 명령어를 일시 보존하는 레지스터
  - 메모리 주소 레지스터(MAR, Memory Address Register)
    - 읽거나 쓰려는 데이터의 메모리 주소를 일시적으로 저장하는 레지스터
  - 메모리 버퍼 레지스터(MBR, Memory Buffer Register)
    - 읽거나 쓰려는 데이터 또는 명령을 일시적으로 저장하는 레지스터

### CPU 내부 버스

- CPU 내부 구성요소 간 정보 전송 통로
- ALU와 레지스터 간 데이터 이동을 위한 데이터 선들과 제어 장치로부터 발생되는 제어 신호 선들로 구성된 내부 버스
- 외부의 시스템 버스들과는 직접 연결 되지 않음
  - 버퍼 레지스터나 시스템 버스 인터페이스 회로를 통해 시스템 버스와 접속

## 2. 명령어의 형식

### 구성

- 연산 코드(Operation Code)
  - 사칙 연산, 보수 연산 등과 같은 동작을 정의하는 부분
    - 동작 코드부라고도 함
  - 명령 코드가 실행되려면 데이터가 필요
  - 입력, 가산, 출력, 시프트, 비교 등의 명령들을 취급
- 오퍼랜드(Operand)
  - 연산을 수행하는 데 필요한 데이터나 데이터의 주소
  - 주기억장치나 보조기억장치의 데이터 주소, 명령 주소, 데이터들을 취급

### 기능

- 전달 기능
  - 정보를 처리하기 위해 중앙처리장치 내 누산기와 기억장치 사이에 정보 교환 필요
  - 프로그램 수행 과정에서 기억장치와 중앙처리장치 사이에서 정보 교환이 일어남
    - 로드(Load)
      - 기억장치에서 중앙처리장치로 정보를 옮겨 오는 것
    - 스토어(Store)
      - 중앙처리장치에서 기억장치에 저장시키는 것
- 함수 연산 기능
  - 연산을 실행하는 명령은 산술적 연산과 논리적 연산을 포함
    - 산술적 연산의 기본 : 사칙 연산, 시프트 명령
    - 논리적 연산의 기본 : AND, OR, NOT 등
- 제어 기능
  - 조건부 분기 명령
    - 프로세스 내의 상태 값에 따라 제어 전송이 발생하거나 발생하지 않을 수 있음
    - 각 명령은 상태 비트 조합에 따라 유효번지로 전송되거나 다음 명령을 계속 수행
  - 서브루틴 명령
    - 어떤 특정한 작업을 수행하도록 일련의 명령들로 구성되어 있는 프로그램
    - 어떤 프로그램이 수행하는 도중에 주프로그램의 여러 위치에서 부프로그램을 부를 수 있음
    - 서브루틴 호출
      - 서브루틴이 호출될 때마다 그 시작 위치로 분기가 일어남
      - 서브루틴이 수행된 이후 다시 주프로그램으로 분기가 일어남
- 입출력 기능(I/O Operation)
  - 입력장치
    - 프로그램과 데이터를 기억장치에 기억시키기 위한 장치
  - 출력장치
    - 기억된 데이터를 출력하여 프로그래머에게 알리는 장치
- 매크로 기능(Macro Operation)
  - 여러 개의 명령어를 한 개로 묶어 사용하는 기능

### 주소에 따른 명령어 형식

- 0-주소 명령어
  - 주소를 지정하는 오퍼랜드 없이 연산 코드만 있는 구조
  - 연산 코드 수행에 있어 연산 결과를 저장할 장소가 고정되어 있는 경우
  - 스택 메모리의 TOP(Stack Pointer)을 가리키는 오퍼랜드를 이용하여 명령 수행
  - 모든 연산은 스택에 있는 자료를 이용하여 수행하고 그 결과 또한 스택에 보존
  - (A + B) × (C - D) 연산 과정
    - 후위 연산식 변환 : AB+CD-×
- 1-주소 명령어
  - 주소를 저장하는 오퍼랜드를 하나만 포함하는 명령어
  - 누산기를 이용하여 오퍼랜드의 데이터와 누산기의 데이터를 계산하여 누산기에 저장
  - (A + B) × (C - D) 연산 과정
    - `LOAD A` : AC ← M[A]
    - `ADD B` : AC ← AC + M[B]
    - `STOR T` : M[T] ← AC
    - `LOAD C` : AC ← M[C]
    - `SUB D` : AC ← AC - M[D]
    - `MUL T` : AC ← AC × M[T]
    - `STOR X` : M[X] ← AC
- 2-주소 명령어
  - 주소를 저장하는 오퍼랜드 2개를 포함하는 명령어
  - 연산 결과를 입력 자료가 기억되어 있던 두 오퍼랜드 중 한 곳에 저장
    - 연산 결과를 저장할 곳의 주소를 명령어 내에 표시할 필요가 없어짐
  - 결과 값을 레지스터와 누산기에 동시에 저장할 수 있으며 계산 결과를 중앙처리장치 내에서 직접 검토 가능
  - (A + B) × (C - D) 연산 과정
    - `MOV R1, A` : R1 ← M[A]
    - `ADD R1, B` : R1 ← R1 + M[B]
    - `MOV R2, C` : R2 ← M[C]
    - `SUB R2, D` : R2 ← R2 - M[D]
    - `MUL R1, R2` : R1 ← R1 × R2
    - `MOV X, R1` : M[X] ← R1
- 3-주소 명령어
  - 주소를 저장하는 오퍼랜드 2개와 연산 결과를 저장하는 오퍼랜드 하나로 구성
  - 여러 개의 범용 레지스터를 가진 컴퓨터에서 사용되는 형식
    - 특수한 목적에만 제한적으로 사용됨
  - 장점
    - 수식 계산의 연산 후에도 입력 자료가 변하지 않고 보존 가능
    - 레지스터의 주소를 사용할 경우 프로그램 길이가 절감됨
  - 단점
    - 레지스터의 수와 기억장치 용량이 고정된 상태에서 명령을 나타날 때 많은 비트가 필요할 수 있음
    - 하나의 명령어를 수행하려면 최소한 4번 기억장치에 액세스하므로 수행 시간이 긺
    - 명령어의 길이가 증가하고 명령어 해독 과정이 복잡해짐
  - (A + B) × (C - D) 연산 과정
    - `ADD R1, A, B` : R1 ← M[A] + M[B]
    - `SUB R2, C, D` : R2 ← M[C] - M[D]
    - `MUL X, R1, R2` : M[X] ← R1 × R2

## 3. 명령어 사이클

- CPU가 한 개의 명령어를 실행하는 데 필요한 전체 처리 과정
- CPU가 프로그램 실행을 시작한 순간부터 끝날 때까지 반복

### 인출 사이클

- CPU가 기억장치로부터 명령어를 읽는 단계
- PC의 내용을 1씩 증가하여 명령어들을 기억장치에 저장되어 있는 순서대로 읽어올 수 있도록 함
- 연산 과정
  - MAR ← PC
    - PC에 저장된 명령어 번지를 MAR로 전송
  - MBR ← M[MAR], PC ← PC+1
    - MAR 번지 메모리 내용인 명령어를 MBR로 전송하고 PC를 증가
  - IR ← MBR
    - 메모리에서 인출해온 명령어를 IR로 전송

### 간접 사이클

- 오퍼랜드 필드에 포함된 간접주소로부터 실제 피연산자가 저장된 유효 주소를 읽는 단계
  - 간접주소 : 유효주소를 저장한 메모리 주소
- 연산 과정
  - MAR ← IR(오퍼랜드)
    - 오퍼랜드 필드에 있는 간접번지를 MAR로 전송
  - MBR ← M[MAR]
    - MAR 번지 메모리 내용인 유효주소를 MBR로 전송
  - IR(오퍼랜드) ← MBR
    - MBR의 내용을 IR로 전송
    - 명령어의 새로운 오퍼랜드 필드에는 실제 피연산자를 가리키는 유효주소가 준비됨

### 실행 사이클

- CPU가 인출된 명령어 코드를 해독하고 그 결과에 따라 필요한 연산을 수행
- 처리 과정
  - 명령어 인출(Instruction Fetch)
    - 기억장치로부터 명령어를 읽어옴
  - 명령어 해독(Instruction Decode)
    - 수행해야 할 동작을 결정하기 위해 명령어 해독
  - 데이터 인출(Data Fetch)
    - 명령어 실행을 위해 데이터가 필요한 경우 기억장치 혹은 I/O 장치로부터 그 데이터를 읽어옴
  - 데이터 처리(Data Process)
    - 데이터에 대한 산술적 혹은 논리적 연산 수행
  - 데이터 저장(Data Store)
    - 수행한 결과 저장
- LOAD 명령
  - 오퍼랜드 필드에 포함된 기억장치 번지 내용을 AC로 로드
  - MAR ← IR(오퍼랜드)
    - 오퍼랜드 필드에 포함된 주소를 MAR로 전송
  - MBR ← M[MAR]
    - MAR 번지 메모리 내용을 MBR로 전송
  - AC ← MBR
    - MBR 내용을 AC로 로드
- STORE 명령
  - AC의 내용을 오퍼랜드 필드에 포함된 기억장치 번지에 저장
  - MAR ← IR(오퍼랜드)
    - 오퍼랜드 필드에 포함된 주소를 MAR로 전송
  - MBR ← AC
    - AC의 내용을 MBR로 전송
  - M[MAR] ← MBR
    - MBR 내용을 MAR 번지 기억장치에 저장
- ADD 명령
  - AC의 내용을 오퍼랜드 필드에 포함된 번지의 내용과 더해 저장
  - MAR ← IR(오퍼랜드)
    - 오퍼랜드 필드에 포함된 주소를 MAR로 전송
  - MBR ← M[MAR]
    - MAR 번지 메모리 내용을 MBR로 전송
  - AC ← AC + MBR
    - AC와 MBR의 합을 구해 다시 누산기로 로드
- JUMP 명령
  - 프로그램의 흐름이 오퍼랜드 필드에 포함된 번지로 분기
  - PC ← IR(오퍼랜드)
    - 오퍼랜드 필드에 포함된 분기 번지를 PC로 전송

### 인터럽트 사이클(Interrupt Cycle)

- 인터럽트 서비스 루틴(ISR, Interrupt Service Routine)의 시작 번지를 호출해 실행을 준비하는 단계
  - 인터럽트 : 프로그램의 정상적인 처리 순서를 방해하는 서비스 요구
  - 소프트웨어 인터럽트는 프로그램의 요청에 의해 발생
  - 하드웨어 인터럽트는 주로 CPU 외부 장치에서 발생
- 인터럽트 요구를 수용하려면 CPU에서 현재 하던 작업을 중단하고 인터럽트를 먼저 처리
- 인터럽트 서비스 루틴의 시작번지를 프로그램 카운터로 불러들여 실행
- 연산 과정
  - MBR ← PC
    - 인터럽트를 마치고 돌아올 본래 프로그램의 주소가 저장된 현재 PC의 내용을 MBR로 전송
  - MAR ← SP, PC ← ISR의 시작번지
    - 현재 SP(Stack Pointer)에 포함된 주소를 MAR로 전송
      - 스택 포인터는 일반적으로 초기에 주기억장치의 마지막 주소를 가리킴
    - PC는 ISR의 시작번지로 이동
  - M[MAR] ← MBR, SP ← SP-1
    - 복귀 주소를 MAR 번지 메모리에 저장
    - SP를 감소시켜 다음 저장 위치를 새로 준비

## 4. 명령어 파이프라이닝

- 명령어 사이클의 각 단계를 다음 단계로 전달하면서 각 단계를 동시에 실행하도록 운영하는 기법
  - 명령어를 병렬로 처리 가능하여 명령어 처리 속도 향상
- 파이프라인
  - 한 데이터 처리 단계의 출력이 다음 단계의 입력으로 이어지는 형태로 연결된 구조

### 단계별 파이프라인

- 명령어 선인출(Instruction Prefetch)
  - 다음에 실행될 명령어를 미리 인출하는 것
- 파이프라인 실행 단계
  - 명령어 인출(Instruction Fetch, IF) 단계
    - 다음 명령어를 기억장치로부터 인출
  - 명령어 해독(Instruction Decoding, ID) 단계
    - 해독기를 이용하여 명령어를 해독
  - 오퍼랜드 인출(Operand Fetch, OF) 단계
    - 기억장치로부터 오퍼랜드를 인출
  - 실행(Execute, EX) 단계
    - 지정된 연산 수행

### 파이프라인 저해 요인(Hazard)

- 하드웨어 설계
  - 파이프라인 하드웨어를 단순화하기 위해 모든 명령어들이 각 단계를 모두 통과하도록 해야 함
    - 묵시적 주소 지정 방식에서 오퍼랜드를 인출할 필요가 없는 경우 등 OF를 위한 사이클이 필요 없이 소모됨
- 병목현상
  - 어느 클록 주기에서의 수행시간이 다른 클록 주기에서의 수행 시간보다 긴 경우 발생
  - 비동기 방식에 의해 어느 정도 해결할 수 있으나 잘 사용되지 않음
- 자원충돌(Resource Conflict)
  - 두 개의 단계가 동시에 하나의 기억장치에 접근하려는 데서 기인
  - 명령어가 들어가는 메모리와 데이터가 들어가는 메모리를 따로 마련함으로써 대부분 해결 가능
- 분기 곤란(Branch Difficulty)
  - 조건 분기 명령어가 실행되는 경우 미리 인출되어 파이프라인에서 처리되던 명령어들이 무효화될 수 있음
  - 분기 곤란으로 인한 성능 저하를 줄이는 방법
    - 분기 목적지 선인출(Prefetch Branch Target)
      - 분기 명령어 다음의 명령어와 함께 분기 목적어가 되는 명령어를 미리 가져오는 방법
      - 분기 조건이 이뤄지지 않을 경우 분기 명령어 다음 명령어로부터 파이프라인을 계속함
      - 분기 조건이 이뤄지는 경우 미리 가져온 목적지의 명령어로부터 파이프라인을 계속함
    - 루프 버퍼(Loop Buffer)
      - 파이프라인의 명령어 인출 단계에 포함되어 있는 작은 고속 기억장치
        - 가장 최근에 인출된 명령어들이 순서대로 저장되어 있음
      - 분기 발생 시 하드웨어가 먼저 분기의 목적지 명령어가 버퍼에 있는지 검사
      - 버퍼에 있으면 다음 명령어는 버퍼로부터 인출
      - 작은 반복 루프들이 포함된 프로그램을 처리하는 경우에 효과적
        - 반복 루프가 크지 않아 전체 루프 버퍼에 저장될 수 있기 때문
    - 분기 예측(Branch Prediction)
      - 분기가 일어날 것인지 예측하고 그에 따라 명령어를 인출하는 확률적 방법
      - 분기 역사 표(Branch History Table)를 이용하여 최근의 분기 결과를 참조함
    - 지연 분기(Delayed Branch)
      - 컴파일 시에 컴파일러가 분기 명령을 탐지하고 파이프라인이 막힘없이 동작되도록 명령어 삽입
      - 대부분의 RISC 프로세서가 채용하는 방법

## 5. 주소 지정 방식

- 연산에 사용될 데이터가 인출될 주기억장치의 위치를 미리 명령어 형식의 오퍼랜드 주소부에 지정하는 방식
- 포인터, 카운터 인덱싱, 프로그램 재배치 등의 편의 제공
- 명령어의 주소 부분 비트를 줄일 수 있음

### 즉시 주소 방식(Immediate Addressing Mode)

- 오퍼랜드가 명령어 자체에 포함되어 있는 방식
- 상수를 레지스터에 초기값으로 줄 때 편리
- 장점
  - 데이터를 인출하기 위해 기억장치를 액세스할 필요가 없어 실행 사이클이 짧아짐
- 단점
  - 사용할 수 있는 수의 크기가 오퍼랜드 필드의 비트 수에 의해 제한

### 직접 주소 방식(Direct Addressing Mode)

- 오퍼랜드에 관한 어드레스 정보가 명령 가운데 직접 위치
  - 명령어의 주소부에 실제 데이터가 들어있는 주기억장치의 주소를 직접 갖고 있음
- 장점
  - 데이터 인출을 위해 한번의 기억장치 액세스만 필요
    - 유효 주소 결정을 위한 다른 절차나 계산이 필요 없음
- 단점
  - 명령어에서 일정 부분은 연산 코드를 위해 사용되기 때문에 남은 비트들만 주소 비트로 사용될 수 있음

### 간접 주소 방식(Indirect Addressing Mode)

- 오퍼랜드 어드레스가 가리키는 위치의 어드레스 지정
- 장점
  - 기억장치를 임의로 사용한다거나 프로그램상의 융통성을 발휘할 수 있음
- 단점
  - 기억장치를 두 번이나 호출해야 함

### 레지스터 주소 지정 방식(Register Addressing Mode)

- 연산에 사용할 데이터가 레지스터에 저장
- 오퍼랜드 필드의 내용이 레지스터 번호
  - 번호가 가리키는 레지스터의 내용이 명령어 실행 과정에서 데이터로 사용

### 레지스터 간접 주소 지정 방식(Register-indirect Addressing Mode)

- 오퍼랜드 필드(레지스터 번호)가 가리키는 레지스터의 내용이 유효 주소가 됨
- 오퍼랜드가 레지스터를 지정하고 다시 그 레지스터의 값이 실제 데이터가 기억된 기억 장소의 주소 지정
- 직접 주소 지정 방식보다 적은 비트 사용

### 인덱스 주소 지정 방식(Indexed Addressing Mode)

- 명령에 포함되어 있는 주소 정보는 인덱스 레지스터의 내용과 더하여 오퍼랜드 주소 결정
- 데이터 배열의 액세스에 주로 사용

### 베이스 레지스터 주소 지정 방식(Base-register Addressing Mode)

- 베이스 레지스터의 내용과 변위를 더해 오퍼랜드 주소 결정
  - 기준이 되는 주소가 저장됨
- 기억장치 내의 프로그램 시작 위치를 지정하는 데 사용
- 프로그램 재배치에 이용