# 자료 표현

## 개요

- 자료
  - 넓은 의미
    - 컴퓨터 시스템의 구성과 이용에 관련 있는 모든 정보
      - 컴퓨터를 운영하기 위해 필요한 정보
      - 컴퓨터 운영 중 발생하거나 상태를 표시하는 정보
      - 컴퓨터를 설치할 때 제공되는 프로그램
  - 좁은 의미
    - 사용자가 입력한 프로그램이나 그 프로그램을 수행하는 데 필요한 데이터
  - 컴퓨터에서 처리한 자료는 전기적 신호나 광학적 신호, 자기적 신호로 바뀌어져 전송되고 기억됨
  - 디지털 회선에서 전송 시 DSU 등의 신호변환기를 통해 일정한 부호화 과정을 거침
    - DSU(Digital Service Unit)
      - 디지털 회선용의 회선 종단 장치
      - 컴퓨터나 각종 DTE를 고속 디지털 전송로에 접속하여 데이터 통신을 하는 데 필요한 장치
        - DTE(Data Terminal Equipment) : 신호를 변환하거나 수신 신호를 재변환하는 종단 장비
  - 베이스 밴드 전송
    - 디지털 형태인 0과 1로 출력되는 직류 신호를 변조하지 않은 채 그대로 전송하는 방식
    - 장거리 전송에는 적합하지 않고, 컴퓨터와 단말기 통신, 근거리 통신에 이용됨
    - 기본 방식
      - 단극 방식
        - 전압의 한쪽 극성(+ 또는 -)만 사용하는 방식
        - 0은 0전압, 1은 양 또는 음의 전압으로 표현
      - 복극 방식
        - 전압의 양쪽 극성(+, -) 모두 사용하는 방식
        - 0은 음의 전압, 1은 양의 전압으로 표현
    - 데이터 전송에서는 바이폴라 방식이 많이 사용됨
      - 바이폴라(Bipolar) 방식
        - 신호가 0이면 극성을 유지, 신호가 1이면 극성 반전

- 파일 시스템의 목적
  - 사용자의 모든 요구 만족
  - 시스템 관점의 처리 능력 극대화
  - 사용자 관점의 응답 시간 최소화
  - 파일 내 자료 유효성 보장
  - 다양한 형태의 저장 매체에 대한 입출력 보장
  - 다중 사용자를 위한 파일 입출력 지원
  - 분실 또는 파손되는 자료 극소화



## 자료의 구성단위

### 파일의 개념

- 파일(File)
  - 자료의 집합 또는 관련된 자료의 집합(바이트의 배열)
  - 컴퓨터 등에서 의미가 있는 정보를 담은 논리적 단위
  - 분류
    - 저장 내용 기준
      - 프로그램 파일(Program File)
        - 원시 프로그램 파일(Source Program File)
        - 목적 프로그램 파일(Object Program File)
        - 실행 파일(Executable File)
      - 데이터 파일(Data File)
    - 저장 정보 형태 기준
      - 텍스트 파일(Text File, ASCII Text File)
      - 이진 파일(Binary File)
  - 주기억장치에 저장 시
    - 일정 길이의 바이트나 비트열의 형태로 저장
  - 보조기억장치에 저장 시
    - 물리 레코드(자료를 입출력하는 기본 단위) 형태로 저장되며 하나 이상의 논리 레코드로 구성

### 구성 요소

- 필드(Field)
  - 파일을 구성하는 기억 영역의 최소 단위로 특정한 한 종류의 자료를 포함한 것
  - 하나의 레코드 중에서 특정 종류의 데이터를 위해 사용되는 지정된 영역
  - 필드 길이(Field Length)
    - 필드의 물리적인 크기
    - 종류
      - 고정 길이 필드(Fixed Length Field)
        - 입력 데이터는 할당된 필드 길이를 초과할 수 없고 입력 후 남은 부분은 빈 공간으로 남음
      - 가변 길이 필드(Variable Length Field)
- 레코드(record)
  - 파일을 액세스할 때 실제로 읽고 쓰는 단위로서 사용되는 자료 단위
  - 하드웨어(보조기억장치 등)에서는 주로 물리 성격의 레코드 사용
  - 보통 여러 논리 레코드를 묶어 물리 레코드가 됨
  - 필요에 따라 하나의 블록을 형성하기도 함
  - 고정 길이 레코드
    - 직접 액세스가 용이하여 일반적으로 많이 사용
    - 레코드의 크기가 너무 작으면 남은 문자열들이 잘리고 너무 크면 저장 공간이 낭비됨
  - 가변 길이 레코드
    - 레코드의 정확한 위치를 파악하기 어려움(직접 액세스 어려움)



## 수의 체계와 변환

### 수의 체계

- 진법 R로 표현한 수의 체계

  ![](https://latex.codecogs.com/svg.image?N=d_nR^n&space;&plus;&space;\cdots&space;&plus;&space;d_2R^2&space;&plus;&space;d_1R^1&space;&plus;&space;d_0R^0)

  - ![](https://latex.codecogs.com/svg.image?N) : 해당되는 수
  - ![](https://latex.codecogs.com/svg.image?d_n) : 해당 자릿값
  - ![](https://latex.codecogs.com/svg.image?R^n) : 가중치 n과 기수

### 진법 변환

- 2진수 ↔ 10진수 변환
  - 2진수 → 10진수 변환
    - 2진수의 밑수가 2임을 이용하여 각 자릿값에 2를 거듭 곱하여 모두 더함
  - 10진수 → 2진수 변환
    - 소수점 위의 수에 대해서는 2로 계속 나눠 그 나머지를 역으로 나열
    - 소수점 이하의 수에 대해서는 2로 거듭 곱하고 그 정수 부분을 취함
    - 동일한 패턴이 계속 반복하여 나오는 경우 절사함
      - 절사(truncate) : 공학적으로 의미가 있는 부분만 남기고 나머지는 버리는 것
- 8진수 ↔ 10진수 변환
  - 2진수 ↔ 10진수 변환 방법과 동일
- 8진수 ↔ 2진수 변환
  - 8진수 → 2진수 변환
    - 8진수 각 자릿값을 2진수로 변환하여 이를 이어 붙임
    - 변환된 2진수 비트들은 최하위비트(LSB, Least Significant Bit)에서 시작하는 3비트 군들로 분류
  - 2진수 → 8진수 변환
    - 최하위비트부터 3비트 군으로 나눠 각 군을 8진수로 변환
      - 매번 3비트 군을 갖지 않으므로 3의 배수로 최상위비트(MSB, Most Significant Bit)에 0 추가
- 16진수 ↔ 10진수 변환
  - 2진수 ↔ 10진수 변환 방법과 동일

- 16진수 ↔ 2진수 변환
  - 8진수 ↔ 2진수 변환 방법에서 4비트 군으로 분류하여 변환



## 숫자 및 문자 코드

- 알파뉴메릭 코드(Alphanumeric Code)
  - 영문자의 대문자와 소문자, 0~9의 숫자, 특수문자 등으로 표현되는 코드

### 숫자 코드

- BCD 코드(Binary-Coded-Decimal code)
  - 2진화 10진 코드, 8421 코드라고도 부름
  - 10진수 각 자릿값을 개별적으로 2진 변환한 코드
  - 1자리의 10진수를 BCD 코드로 표현하는 데 2진수 4자리 필요
    - 1010, 1011, 1100, 1101, 1110, 1111은 사용하지 않음
  - 2진수보다 더 많은 비트들이 필요하여 덜 효율적
  - 연산에 대한 논리 절차는 2진수보다 복잡하므로 더 복잡한 회로 필요
- 3초과 코드(Excess 3 code)
  - BCD 코드에 기준을 두고 2진수 0011(3)을 더해 표현한 코드
  - 코드 각 자릿값을 반전시켜 9의 보수를 간단히 구할 수 있음
    - 자보수 코드(Self Complementing Code) : 2진수 상호교환에 의해 보수를 얻을 수 있는 코드
  - 0이 되는 경우가 없으므로 신호가 없는 상태와 구별할 수 있음
- 2421 코드
  - 8421 코드에서 맨 처음 수의 자릿값이 2인인 코드
  - 4까지는 8421 코드와 같으나 5부터 2진수 1011(11)로 시작
  - 3초과 코드와 동일하게 각 자릿값을 반전시켜 9의 보수를 얻을 수 있는 자보수 코드
- 51111 코드
  - 1부터 4까지는 1이 왼쪽으로, 6부터 9까지는 1이 오른쪽으로 하나씩 늘어나는 자보수 코드
  - 전자회로에서 동작이 용이하게 이뤄짐
- 5421 코드
  - 맨 왼쪽 비트가 0이면 4 이하의 10진수, 1이면 5 이상의 10진수라는 것이 쉽게 파악되는 코드
- 7421 코드
  - 맨 왼쪽 비트가 0이면 6 이하의 10진수, 1이면 7 이상의 10진수라는 것이 쉽게 파악되는 코드

| 10진수 | 2진수 | 8421 코드 | 3초과 코드 | 2421 코드 | 51111 코드 |
| ------ | ----- | --------- | ---------- | --------- | ---------- |
| 0      | 0000  | 0000      | 0011       | 0000      | 00000      |
| 1      | 0001  | 0001      | 0100       | 0001      | 00001      |
| 2      | 0010  | 0010      | 0101       | 0010      | 00011      |
| 3      | 0011  | 0011      | 0110       | 0011      | 00111      |
| 4      | 0100  | 0100      | 0111       | 0100      | 01111      |
| 5      | 0101  | 0101      | 1000       | 1011      | 10000      |
| 6      | 0110  | 0110      | 1001       | 1100      | 11000      |
| 7      | 0111  | 0111      | 1010       | 1101      | 11100      |
| 8      | 1000  | 1000      | 1011       | 1110      | 11110      |
| 9      | 1001  | 1001      | 1100       | 1111      | 11111      |

- 그레이 코드(Gray Code)
  - 최소 변화 코드(Minimum Change Code)로서 연속되는 코드 간 비트가 1개씩 변화
  - 비가중치 코드로 코드군에서 비트들이 할당된 자리가 어떤 가중치도 갖지 않음
    - 가중치 코드(Weighted Code)
      - 코드화한 2진 표현의 각 자릿값이 의미 있는 특정 값에 대응되는 코드
      - 8421 코드 등
    - 비가중치 코드(Unweighted Code)
      - 코드화한 2진 표현의 각 자리값이 의미 있는 특정 값에 대응되지 않는 코드
      - 3초과 코드 등
  - 2진수 → 그레이 코드
    - 최상위비트는 그대로 두고, 이후 비트부터는 2진수의 앞 비트와 합해 올림수를 없앰(XOR 연산)
  - 그레이 코드 → 2진수
    - 최상위비트는 그대로 두고, 이후 비트부터는 변환된 2진수의 앞 비트와 합해 올림수를 없앰
  - 적용 예
    - 광학 축 위치 부호기에서 회전판 위치에 대한 입력 코드
    - QAM(Quadrature Amplitude Modulation)의 제한된 전송 대역에서의 데이터 전송효율 향상
    - PCM(Pulse Code Modulation)의 부호화

### 문자 코드

- 문자 코드

  - 문자와 기타 기호까지 포함된 코드
  - 내부 코드(Internal Code)
    - 컴퓨터 내부에서 사용하는 코드
    - EBCDIC 등
  - 외부 통신 코드(External Communication Code)
    - 컴퓨터와 외부 장치가 통신하기 위한 코드
    - ASCII 등

- EBCDIC(Extended Binary Coded Decimal Interchange Code)

  - IBM에서 개발한 문자 데이터 내부 표시에 사용되는 코드
  - 4개의 존 비트와 4개의 숫자 비트로 구성
  - 256개의 숫자, 영문자, 특수 문자 등을 표현
  - 컴퓨터 간 정보 교환을 위한 통신 코드가 아니므로 패리티 비트가 없음
    - 패리티 비트(Parity Bit) : 정보 전달 과정에서의 데이터 오류를 검출하기 위한 비트
  - 숫자의 경우 문자가 아닌 한 숫자 비트만 남아 BCD 코드가 되어 기억 공간 절약

  ![image-20220708114752515](C:\Users\pen2402\AppData\Roaming\Typora\typora-user-images\image-20220708114752515.png)

- ASCII(American Standard Code for Information Interchange)

  - 미국에서 표준화한 7비트의 정보 교환용 외부 통신 코드
  - 1개의 패리티 비트, 3개의 존 비트, 4개의 숫자 비트로 구성
  - 128개의 문자 표현 가능
  - 확장 아스키(Extended ASCII)
    - 패리티 비트를 존 비트로 사용하여 256개의 문자 표현 가능
  - 문자가 인쇄되지 않는 라인피드 또는 기계 자체의 제어 명령을 위해 사용 데이터 통신에 널리 이용됨

  ![image-20220708122927977](C:\Users\pen2402\AppData\Roaming\Typora\typora-user-images\image-20220708122927977.png)



## 에러 검출 코드

- 에러(Error)
  - 전송 매체를 통해 전송된 데이터가 오류로 인해 실제 전송된 내용이 수신측에 변질되어 나타나는 요인
- 에러 제어(Error Control)
  - 송신과 수신 간 정확한 정보를 주고받기 위한 제어


### 에러 검출 부호를 사용하는 방식

- 패리티 검사 방식
  - 한 블록의 데이터 끝에 패리티 비트를 추가하여 오류를 검출하는 방식
  - 검사 방식 종류
    - 홀수 패리티 방식
      - 패리티 비트를 포함한 1의 비트 수를 항상 홀수 개로 유지
      - 주로 비동기식 전송에 사용
    - 짝수 패리티 방식
      - 패리티 비트를 포함한 1의 비트 수를 항상 짝수 개로 유지
      - 주로 동기식 전송에 사용
  - 짝수 개의 비트로 에러가 발생하는 경우 에러를 검출하지 못함
- 블록 합 검사(Block Sum Check)
  - 각 비트를 가로와 세로로 두 번 관찰하는 이차원 패리티 검사 방식
  - 연집 에러(Burst Error)를 검출할 가능성을 높임
    - 연집 에러(Burst Error) : 한 단위의 데이터에 집단적으로 발생한 에러
  - 동기식 전송 방식에 사용
  - 구성
    - 수직 중복 검사(VRC, Vertical Redundancy Check)
      - 전송 비트 끝에 패리티 비트를 두는 검사 방식
      - 일반적인 패리티 검사
    - 수평 중복 검사(LRC, Longitudinal Redundancy Check)
      - 전송 비트의 자릿값을 일정 블록 단위로 묶어 각 블록 끝(열)에 패리티 비트를 두는 검사 방식
      - 패리티 비트들이 모여 하나의 패리티 검사 문자를 이룸
        - 패리티 검사 문자는 블록 검사 문자(BCC, Block Check Character)라고도 함
- CRC(Cyclic Redundancy Check)
  - 1비트 에러 제어가 아닌 다수 비트에 의해 에러를 제어하는 방식
  - ARQ 방식에 의한 에러 검출로 부가적 데이터 비트에 의한 대역폭 증가
    - ARQ(Automatic Request) 방식
      - 수신 측 정보에 에러 정정 부호를 삽입할 필요가 없고 프레임에 FCS만 붙어 구현이 비교적 간단
      - 수신 측이 자체적으로 에러를 정정하지 못하고 재전송에 드는 대역폭 손실이 큼
      - 에러 검출 부호에서 사용
    - FEC(Forward Error Correction) 방식
      - 수신 측에서 에러를 정정할 수 있고 재전송을 하지 않아 대역폭 관리에 효율적
      - 에러 정정 부호의 삽입으로 프레임 크기가 커지고 구현이 어려움
      - 에러 정정 부호에서 사용
  - 계산된 FCS를 정보 프레임과 함께 전송하여 수신 측에서 동일 알고리즘으로 FCS를 계산하여 비교
    - FCS(Frame Check Sequence) : 프레임 내 오류를 검출하기 위한 비트열

### 에러 정정 부호를 사용하는 방식

- 해밍 부호(Hamming Code)

  - 미국 Bell 연구소의 해밍에 의해 고안된 방법으로 n개의 정보 비트와 k개의 해밍 비트로 운용

  - 에러를 검출하는 데 필요한 잉여 데이터비트들의 수를 최소화

    ![](https://latex.codecogs.com/svg.image?2^k\geq&space;m&plus;1=k&plus;n&plus;1)

    - 위 관계식을 만족하는 k개의 비트로 결정
    - 정보 비트의 각 2의 거듭 제곱 자리에 패리티 비트를 추가

  - 해밍 가중치(Hamming Weight) : 어떤 부호어(Cord word)에서 1의 개수

  - 해밍 거리(Hamming Distance) : 같은 비트 수를 갖는 2진 부호 사이에서 비트 값이 일치되지 않는 수

- 길쌈 부호(Convolution Code)

  - 블록 부호와 달리 패리티 비트가 계속적으로 삽입됨
  - 현재의 입력이 과거의 입력에 대해 영향을 받아 부호화하는 비블록 부호 중 하나
  - 필요 요소
    - 시프트 레지스터 
      - 정보를 암호화할 때 사용되는 일종의 기억장치

    - 생성다항식
      - 시프트 레지스터와 결과 값을 연결할 때 사용되는 식

  - 특징
    - 인코딩 및 디코딩이 복잡함
    - 에러 검출 및 정정 성능이 높음

