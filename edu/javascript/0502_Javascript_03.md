# Javascript 03

## AJAX

- 등장 배경
  - 2005년 Google Maps & Gmail 등에 활용되는 기술을 설명하기 위해 최초로 사용
  - 특정 기술이 아닌 기존의 여러 기술을 사용하는 새로운 접근법을 설명하는 용어
    - 기존 기술을 잘 활용할 수 있는 방식으로 구성 및 재조합한 새로운 접근법

- 페이지 전체를 새로고침(reload)하지 않고서도 수행되는 비동기성
  - 서버의 응답에 따라 전체 페이지가 아닌 일부분만 업데이트할 수 있음
- AJAX로 수행할 수 있는 작업
  - 페이지 새로고침 없이 서버에 요청
  - 서버로부터 데이터를 받고 작업 수행
- XMLHttpRequest 객체
  - 서버와 상호작용하기 위해 사용되며 전체 페이지의 새로고침 없이 데이터를 받아올 수 있음
  - 사용자의 작업을 방해하지 않으면서 페이지 일부를 업데이트할 수 있음
  - 주로 AJAX 프로그래밍에 사용
  - 이름과 달리 XML뿐만 아니라 모든 종류의 데이터를 받아올 수 있음
  - 생성자
    - `XMLHttpRequest()`



## Asynchronous JavaScript

- 동기식
  - 순차적, 직렬적 Task 수행
  - 요청을 보낸 후 응답을 받아야만 다음 동작이 이루어짐(blocking)
- 비동기식
  - 병렬적 Task 수행
  - 요청을 보낸 후 응답을 기다리지 않고 다음 동작이 이루어짐(non-blocking)
- 자바스크립트는 single threaded로 비동기식
  - 컴퓨터가 여러 CPU를 갖고 있더라도 main thread라 불리는 단일 스레드에서만 작업 수행
  - 이벤트를 처리하는 Call Stack이 하나인 언어
  - 과정
    1. 즉시 처리하지 못하는 이벤트들을 Web API로 보내서 처리하도록 함
    2. 처리된 이벤트들은 처리된 순서대로 Task Queue에서 대기
    3. Call Stack이 비면 Event Loop가 Task Queue에서 가장 오래 대기한 이벤트를 Call Stack으로 보냄
- 비동기 사용 이유
  - 사용자 경험(UX)
    - 매우 큰 데이터를 동반하는 앱의 경우 동기식 코드라면 데이터를 모두 불러온 뒤 앱이 실행
      - 데이터를 모두 불러올 때까지는 앱이 모두 멈춘 것처럼 보임
      - 코드 실행을 차단하여 화면이 멈추고 응답하지 않는 것 같은 사용자 경험을 제공
    - 비동기식 코드라면 데이터를 요청하고 응답 받는 동안 앱 실행을 함께 진행함
      - 데이터를 불러오는 동안 지속적으로 응답하는 화면을 보여줌으로써 더욱 쾌적한 UX 제공
    - 때문에 많은 웹 API 기능은 현재 비동기 코드를 사용하여 실행
- Threads
  - 프로그램이 작업을 완료하기 위해 사용할 수 있는 단일 프로세스
  - 각 스레드는 한 번에 하나의 작업만 수행할 수 있음
    - 다음 작업을 시작하려면 앞의 작업이 완료되어야 함
    - 컴퓨터 CPU는 여러 코어를 가지고 있어 한 번에 여러 일을 처리할 수 있음
- Concurrency model
  - Call Stack
    - 요청이 들어올 때마다 해당 요청을 순차적으로 처리하는 Stack(LIFO) 형태의 자료구조
  - Web API(Browser API)
    - 자바스크립트 엔진이 아닌 브라우저 영역에서 제공하는 API
    - `setTimeout()`, DOM events, AJAX 요청 등을 처리
  - Task Queue(Event Queue, Message Queue)
    - 비동기 처리된 callback 함수가 대기하는 Queue(FIFO) 형태의 자료구조
    - main thread가 끝난 후 실행되어 후속 JavaScript 코드가 차단되는 것을 방지
  - Event Loop
    - Call Stack이 비어 있는지 확인
    - 비어 있는 경우 Task Queue에서 실행 대기 중인 callback 함수가 있는지 확인
    - Task Queue에 대기 중인 callback 함수가 있다면 가장 앞의 callback 함수를 Call Stack으로 push
- Zero delays
  - delay는 JavaScript가 요청을 처리하는 데 필요한 최소 시간
    - 실제로 0ms 후 callback 함수의 시작을 보장하지 않음
    - 실행은 Task Queue에 대기 중인 작업 수에 따라 다름
  - 기본적으로 `setTimeout()` 함수는 설정된 시간이 지나도 메시지의 모든 코드들이 완료될 때까지 대기
- 순차적 비동기 처리
  - Web API로 들어오는 순서보다 어떤 이벤트가 먼저 처리되느냐가 중요(실행 순서 불명확)
  - 순차적 비동기 처리를 위한 작성 방식
    - Async callbacks
      - 백그라운드에서 실행을 시작할 함수를 호출할 대 인자로 지정된 함수
      - `addEventListener()`의 두 번째 인자 등
    - promise-style
      - Modern Web APIs에서의 새로운 코드 스타일
      - XMLHttpRequest 객체를 사용하는 구조보다 조금 더 현대적인 버전



## Callback Function

- Callback function
  - 다른 함수에 인자로 전달된 함수
  - 외부 함수 내에서 호출되어 일종의 루틴 또는 작업을 완료함
  - 동기식, 비동기식 모두 사용됨
    - 주로 비동기 작업이 완료된 후 코드 실행을 계속하는 데 사용
  - 비동기 작업이 완료된 후 코드 실행을 계속하는 데 사용되는 경우를 비동기 콜백이라고 함
- 일급 객체(일급 함수)
  - 다른 객체들에 적용할 수 있는 연산을 모두 지원하는 객체(함수)
  - 자바스크립트 함수는 일급 객체
  - 일급 객체 조건
    - 인자로 넘길 수 있어야 함
    - 함수의 반환 값으로 사용할 수 있어야 함
    - 변수에 할당할 수 있어야 함
- Async callbacks
  - 백그라운드에서 코드 실행을 시작할 함수를 호출할 때 인자로 지정된 함수
  - 백그라운드 코드 실행 이후 작업이 완료되었음을 알리거나 다음 작업을 실행하도록 할 수 있음
  - 다른 함수의 인자로 전달 시 함수 참조를 전달할 뿐 즉시 실행되지 않고 함수의 body에서 called back됨
    - 정의된 함수는 때가 되면 callback 함수를 실행하는 역할
- callback 함수 사용 이유
  - callback 함수는 명시적 호출이 아닌 특정 루틴 혹은 action에 의해 호출되는 함수
  - 비동기 로직을 수행할 때 callback 함수는 필수
    - 명시적인 호출이 아니라 다른 함수의 매개변수로 전달하여 해당 함수 내에서 특정 시점에 호출

- callback hell
  - 순차적인 연쇄 비동기 작업을 처리하기 위해 callback 함수 호출의 패턴이 지속적으로 반복
    - 여러 개의 연쇄 비동기 작업을 할 때 일어나는 상황
    - 디버깅, 코드 가독성 부분에서 어려움 발생
  - 해결
    - 코드 깊이 얕게 유지
    - 모듈화
    - 모든 단일 오류 처리
    - Promise 콜백 방식 사용



## Promise

- Promise object
  - 비동기 작업의 최종 완료 또는 실패를 나타내는 객체
    - 미래의 완료 또는 실패와 그 결과 값을 나타냄
    - 미래의 어떤 상황에 대한 약속

- methods

  - `.then()`
    - 성공(이행)에 대한 약속
    - 이전 작업이 성공했을 때 수행할 작업을 나타내는 callback 함수
    - 각 callback 함수는 이전 작업의 성공 결과를 인자로 전달 받음
      - 성공했을 때의 코드를 callback 함수 안에 작성
    - 각 `.then()` 블록은 서로 다른 promise를 반환
      - 여러 블록을 통해 연쇄적인 작업 수행 가능
      - 여러 비동기 작업을 차례대로 수행할 수 있음

  - `.catch()`
    - 실패(거절)에 대한 약속
    - `.then()`이 하나라도 실패하면(거부되면) 동작(동기식의 try-except 구문과 유사)
    - 이전 작업의 실패로 인해 생성된 error 객체는 catch 블록 안에서 사용할 수 있음
  - `.finally(callback)`
    - promise 객체 반환
    - 결과와 상관없이 무조건 지정된 callback 함수 실행
    - 어떠한 인자도 전달받지 않음
      - 성공 여부를 promise에서 판단할 수 없기 때문
    - 무조건 실행되어야 하는 절에서 활용
      - `.then()`과 `.catch()` 블록에서의 코드 중복 방지
  - `.then()`과 `.catch()` 메소드는 모두 promise를 반환하기 때문에 chaining 가능
    - 반환 값이 반드시 있어야 함
    - 없으면 callback 함수가 이전의 promise 결과를 받을 수 없음

- Promise가 보장하는 것
  - callback 함수는 JavaScript의 EventLoop가 현재 실행 중인 Call Stack 완료 이전에 절대 호출되지 않음
    - Promise callback 함수는 Event Queue에 배치되는 엄격한 순서로 호출
    - 비동기 작업이 성공하거나 실패한 뒤에 `.then()` 메소드를 이용하여 추가한 경우에도 동작
  - .then()을 여러 번 사용하여 여러 개의 callback 함수를 추가할 수 있음(Chaining)
    - 각각의 callback은 주어진 순서대로 하나하나 실행하게 됨
    - Promise의 가장 큰 장점



## Axios

- Axios
  - 브라우저를 위한 Promise 기반의 클라이언트
  - XHR 브라우저 내장 객체보다 편리한 AJAX 요청 가능
    - 확장 가능한 인터페이스와 함께 패키지로 사용이 간편한 라이브러리 제공



## async & await

- 비동기 코드를 작성하는 새로운 방법
  - ECMAScript 2017(ES8)에서 등장
- 기존 Promise 시스템 위에 구축된 syntactic sugar
  - Promise 구조의 then chaining 제거
  - 비동기 코드를 조금 더 동기 코드처럼 표현
  - Syntactic sugar
    - 더 쉽게 읽고 표현할 수 있도록 설계된 프로그래밍 언어 내의 구문
    - 문법적 기능은 그대로 유지하되 사용자가 직관적으로 코드를 읽을 수 있게 만듦