# 운영체제 구조

## 운영체제 서비스

- 운영체제는 프로그램이 실행되는 환경을 제공
  - 내부적으로 여러 다른 노선을 따라 구성되므로 운영체제의 구조는 차이가 있음
  - 프로그램과 프로그램 사용자에게 특정 서비스를 제공

- 운영체제 서비스
  - 사용자 인터페이스(UI, User Interface)
    - 그래픽 사용자 인터페이스(GUI)
    - 터치스크린 인터페이스
    - 명령어 라인 인터페이스(CLI)

  - 프로그램 수행
    - 시스템은 프로그램을 메모리에 적재해 실행할 수 있어야 함
    - 프로그램은 정상적이든 비정상적이든 실행을 끝낼 수 있어야 함

  - 입출력 연산
    - 수행 중인 프로그램은 입출력을 요구할 수 있음
    - 효율과 보호를 위해 사용자들은 통상 입출력 장치를 직접 제어할 수 없음
      - 운영체제가 입출력 수행의 수단을 제공해야 함

  - 파일 시스템 조작
    - 프로그램은 파일을 읽고 쓸 필요가 있음
      - 파일 생성 및 삭제, 지정된 파일 찾기, 파일 정보 열거 등

    - 소유권에 기반한 권한 관리로 파일이나 디렉토리 접근을 허가할 수 있게 함

  - 통신
    - 종류
      - 동일한 컴퓨터에서 수행되고 있는 프로세스 간 통신
      - 네트워크에 의해 함께 묶여 있는 서로 다른 컴퓨터 시스템상에서 수행되는 프로세스 간 통신

    - 공유 메모리를 통해서나 정보 패킷이 이동하는 메시지 전달 기법을 사용해 구현될 수 있음

  - 오류 탐지
    - 운영체제는 모든 가능한 오류를 항상 의식하고 적절한 조치를 할 수 있어야 함

  - 자원 할당
    - 여러 다른 종류의 자원을 관리
    - 다수의 프로세스나 작업이 동시에 실행될 때 각각에 자원을 할당해야 함

  - 기록 작성
    - 어떤 프로그램이 어떤 종류의 컴퓨터 자원을 얼마나 많이 사용하는지와 같은 기록 관리

  - 보호와 보안
    - 보호는 시스템 자원에 대한 모든 접근이 통제되도록 보장하는 것을 필요로 함
      - 서로 다른 여러 프로세스가 병행 수행될 때 다른 프로세스나 운영체제 자체를 방해해서는 안 됨

    - 보안은 각 사용자가 자원에 접근할 때 비밀번호 등으로 자신을 인증하는 것부터 시작
      - 외부 입출력 장치들을 부적합한 접근 시도로부터 지킴
      - 침입 탐지를 위해 모든 접속을 기록하는 것으로 확장

    - 보호와 보안 유지를 위해 시스템 전체에 걸쳐 예방책이 제정되어야 함



## 사용자와 운영체제 인터페이스

- 명령 인터프리터
  - 셸(Shell)
    - 선택할 수 있는 여러 명령 인터프리터를 제공하는 시스템에서의 해석기
  - 사용자가 지정한 명령을 가져와서 그것을 수행하는 것
    - 명령 인터프리터 자체가 명령을 실행할 코드를 가지는 경우
      - 각 명령이 자신의 구현 코드를 요구하므로 명령의 수가 명령 인터프리터의 크기를 결정
    - 시스템 프로그램에 의해 대부분의 명령을 구현하는 경우
      - 명령 인터프리터는 명령을 알지 못하고 메모리에 적재되어 실행될 파일 식별을 위해 명령 사용
- 그래픽 기반 사용자 인터페이스
  - 마우스를 통해 마우스 포인터를 움직여 화면상의 윈도 메뉴 시스템 사용
  - 프로그램을 호출하거나 파일 혹은 디렉토리를 선택하거나 명령을 포함한 메뉴를 드래그할 수도 있음
- 터치스크린 인터페이스
  - 사용자는 터치스크린에서 여러 제스처를 취해 상호 작용함



## 시스템 콜

- 프로세스가 운영체제에게 어떤 서비스를 요청하는 방법
  - 응용 프로그램이 사용할 수 있도록 운영체제가 제공하는 서비스 집합의 일부
  - 운영체제에 의해 사용할 수 있는 서비스에 대한 인터페이스 제공
- 예제
  - `cp input.txt output.txt`
    - 입력 파일 이름 획득
      - 화면에 프롬프트 출력
      - 입력 받아들임
    - 출력 파일 이름 획득
      - 화면에 프롬프트 출력
      - 입력 받아들임
    - 입력 파일 열기
      - 파일이 존재하지 않는 경우 비정상적으로 종료
    - 출력 파일 생성
      - 이미 파일이 존재하는 경우 비정상적으로 종료
    - 루프(읽기가 실패할 때까지)
      - 입력 파일로부터 읽어 들임
      - 출력 파일에 씀
    - 출력 파일 닫기
    - 화면에 완료 메시지 출력
    - 정상적으로 종료
- 응용 프로그래밍 인터페이스(API, Application Programming Interface)
  - 대부분의 응용 개발자들은 응용 프로그래밍 인터페이스에 따라 프로그램을 설계
  - API는 각 함수에 전달되어야 할 매개변수들과 반환 값을 포함하여 사용 가능한 함수 집합을 명시
  - 시스템 콜보다 API에 따라 프로그래밍하는 것을 선호하는 이유
    - 프로그램 호환성
      - API를 지원하는 여러 시스템에서 컴파일되고 실행된다는 것을 기대할 수 있음
    - 사용성
      - 시스템 콜은 종종 더 자세한 명세가 필요하고 작업이 더 어려움
  - API 함수 호출과 커널의 관련된 시스템 콜을 호출하는 것에는 강한 상관관계 존재
    - 대부분의 API가 여러 운영체제에서 제공하는 고유의 시스템 콜과 유사
  - 런타임 환경(RTE)
    - 프로세스나 프로그램이 실행되는 소프트웨어 환경
    - 운영체제가 제공하는 시스템 콜에 대한 연결고리 역할을 하는 시스템 콜 인터페이스 제공
  - 운영체제에 인자를 전달하는 방법
    - 인자를 레지스터 내에 전달
      - 레지스터보다 많은 매개변수가 있는 경우
    - 인자의 주소를 레지스터 내에 인자로 전달
      - 인자는 메모리 내 블록이나 테이블에 저장
    - 스택을 통한 전달
- 시스템 콜의 유형
  - 프로세스 제어
    - 실행 중인 프로그램은 수행을 정상적 또는 비정상적으로 멈출 수 있어야 함
    - 비정상적으로 중지하기 위해 시스템 콜이 호출되거나 문제가 발생해 오류 트랩을 유발하는 경우
      - 메모리 덤프가 행해지고 오류 메시지가 생성되고 기록되어 이후 디버거에 의해 검사될 수 있음
  - 파일 조작
    - 파일 생성, 삭제, 열기, 닫기, 읽기, 쓰기, 위치 변경, 되감기 등
  - 장치 관리
    - 운영체제에 의해 제어되는 다양한 자원들은 장치로 간주될 수 있음
  - 정보 유지보수
    - 많은 시스템 콜은 단순히 사용자 프로그램과 운영체제 간 정보 전달을 위해 존재
    - 메모리를 덤프하기 위한 시스템 콜 제공으로 프로그램 디버깅에 유용
    - 프로그램의 시간 프로파일(프로그램이 특정 위치나 위치 집합에서 수행한 시간) 제공
    - 현재 운영되고 있는 모든 프로세스에 관한 정보를 갖고 이에 접근하기 위한 시스템 콜 존재
  - 통신
    - 메시지 전달 모델
      - 통신하는 두 프로세스가 정보를 교환하기 위해 서로 메시지를 주고받음
      - 반드시 통신이 이뤄지기 전에 연결이 되어야 하며 상대 통신자의 이름을 알고 있어야 함
      - 네트워크의 각 컴퓨터는 호스트 이름을 갖고 각 프로세스는 프로세스 이름을 가짐
      - 연결을 받아들일 프로세스들은 연결을 위해 대기 호출을 수행하고 연결이 이루어질 때 깨어남
        - 데몬(Daemon)
          - 서비스 요청에 응답하기 위해 실행되는 백그라운드 프로세스
      - 특징
        - 피해야 할 충돌이 없으므로 소량 데이터 교환에 유용
        - 메모리 공유보다 구현하기 쉬움
    - 공유 메모리 모델
      - 서로 다른 프로세스가 공유 영역에서 데이터를 읽고 씀으로써 정보를 교환
      - 정상적으로 운영체제는 한 프로세스가 다른 프로세스의 메모리에 접근하는 것을 막음
        - 두 개 이상의 프로세스가 접근을 허용하는 것에 동의 필요
        - 동일한 위치에 동시에 쓰지 않도록 보장할 책임
      - 특징
        - 한 컴퓨터 내에서는 메모리 전송 속도로 수행할 수 있어 빠르고 편리한 통신을 허용
        - 보호와 동기화 부분에서 여러 문제점을 가짐
  - 보호
    - 컴퓨터 시스템이 제공하는 자원에 대한 접근을 제어하기 위한 기법 지원



## 시스템 서비스

- 파일 관리
  - 파일과 디렉토리를 생성, 삭제, 복사, 이름 변경, 인쇄, 열거, 조작함

- 상태 정보
  - 날짜, 시간, 사용 가능한 메모리와 디스크 공간, 사용자 수 등
    - 상세한 성능, 로깅 및 디버깅 정보를 제공하기도 함

- 파일 변경
  - 파일의 내용을 생성하고 변경하기 위해 다수의 문장 편집기를 사용할 수 있음
    - 파일 내용 검색이나 변환하기 위한 특수 명령어가 제공되기도 함

- 프로그래밍 언어 지원
  - 일반적인 프로그래밍 언어들에 대한 컴파일러, 어셈블러, 디버거 및 해석기가 제공되거나 설치할 수 있음

- 프로그램 적재와 수행
  - 프로그램이 수행되기 위해 메모리에 적재되어야 함
  - 절대 로더, 재배치 로더, 링키지 에디터 등을 제공
    - 절대 로더 : 지정된 주소에 적재만 담당하는 로더
    - 재배치 로더 : 프로그램에 대한 기억 장소 할당과 연결을 자동으로 수행하는 로더
    - 링키지 에디터(링커) : 로드 모듈을 작성하는 데 사용하는 시스템 프로그램

  - 고급어나 기계어를 위한 디버깅 시스템 필요

- 통신
  - 프로세스, 사용자, 다른 컴퓨터 시스템 사이의 가상 접속을 이루기 위한 기법 제공

- 백그라운드 서비스
  - 시스템이 정지될 때까지 계속해서 실행되는 프로세스
  - 서비스, 서브시스템, 데몬 등




## 링커와 로더

- 일반적으로 프로그램은 디스크에 이진 실행 파일로 존재
  - CPU에서 실행하려면 프로그램을 메모리로 가져와 프로세스 형태로 배치되어야 함
- 소스 파일
  - 임의의 물리 메모리 위치에 적재되도록 설계된 오브젝트 파일로 컴파일됨
    - 재배치 가능 오브젝트 파일 생성
  - 링커
    - 재배치 가능 오브젝트 파일을 하나의 이진 실행 파일로 결합
      - 실행 가능한 로드 모듈(프로그램) 생성
    - 링킹 과정에서 다른 오브젝트 파일이나 라이브러리를 포함할 수 있음
  - 로더
    - 이진 실행 파일을 메모리에 적재하는 데 사용
      - 프로그램이 CPU 코어에서 실행할 수 있는 상태가 됨
- 오브젝트 파일 및 실행 파일은 일반적으로 표준화된 형식을 가짐
  - ELF(UNIX 및 Linux 시스템), PE(Windows), Mach-O(macOS) 등



## 응용 프로그램이 운영체제마다 다른 이유

- 기본적으로 한 운영체제에서 컴파일된 응용 프로그램은 다른 운영체제에서 실행할 수 없음
  - 각 운영체제는 고유한 시스템 콜 집합을 제공
- 응용 프로그램이 여러 운영체제에서 실행되도록 하는 방법
  -  운영체제마다 인터프리터가 제공되는 인터프리터 언어로 작성
    - 소스 프로그램의 각 라인을 읽고 상응하는 기계어 명령을 실행하여 해당 운영체제의 시스템 콜 호출
    - 기계어 코드로 구성된 응용 프로그램보다 성능이 떨어지고 기능이 제한될 수 있음
  - 실행 중인 응용 프로그램을 포함하고 있는 가상 머신을 가진 언어로 작성
    - 인터프리터 시스템과 유사한 단점을 가짐
  - 컴파일러가 기기 및 운영체제 고유의 이진 파일을 생성하는 표준 언어 또는 API 사용
- 응용 프로그램의 이동성이 부족한 이유
  - 각 운영체제에 헤더, 명령어 및 변수의 배치를 강제하는 응용 프로그램 이진 형식 존재
    - 명시된 구조 형태로 실행 파일 내 특정 위치에 있어야 프로그램을 올바르게 실행할 수 있음
  - CPU는 다양한 명령어 집합을 갖고 해당 명령어가 포함된 응용 프로그램만 올바르게 실행할 수 있음
  - 운영체제는 고유한 시스템 콜을 제공하여 여러 측면에서 운영체제마다 다름
    - 피연산자, 피연산자 순서, 호출 방법, 시스템 콜 번호, 의미, 반환 결과 등
- 해결에 도움되는 몇 가지 방법
  - 표준화된 형식
    - Linux 및 UNIX 시스템에서는 ELF 형식의 공통 표준을 제공
  - ABI(Application Binary Interface)
    - 아키텍처 수준에서의 API
      - 이진 코드의 여러 구성 요소가 주어진 아키텍처에서 특정 운영체제와 상호 작용할 수 있도록 함
    - 플랫폼 간 호환성을 거의 제공하지 않음
      - 특정 아키텍처에서 실행되는 특정 운영체제에 대한 ABI가 정의되어 있음



## 운영체제 설계 및 구현

- 설계 목표
  - 시스템 목표와 명세 정의
  - 운영체제는 설계, 구현, 유지보수가 쉬워야 하며 적응성, 신뢰성, 무오류, 효율성을 가져야 함
  - 많은 시스템에서 다른 요구 조건들이 다른 환경을 위해 다양한 해결 방법을 낳을 수 있음
- 기법과 정책
  - 기법으로부터 정책을 분리하는 것이 원칙
  - 기법
    - 어떤 일을 어떻게 할 것인지 결정하는 것
  - 정책
    - 무엇을 할 것인지 결정하는 것
    - 정책은 장소가 바뀌거나 시간이 흐름에 따라 변경될 수 있음
      - 여러 정책에서 사용되기에 충분히 융통성 있는 일반적인 기법이 더 바람직
- 구현
  - 고급 언어나 최소한 시스템 구현 언어를 사용함으로써 생기는 장점
    - 코드를 빨리 작성할 수 있고 더 간결해지고 이해하기 쉽고 디버그하기 쉬움
    - 컴파일러 기술의 향상은 단순 재컴파일에 의해 전체 운영체제를 위해 생성된 코드 성능을 향상
    - 운영체제가 고급 언어로 작성된 경우 다른 하드웨어로 이식하는 것이 훨씬 쉬움
      - 속도가 느리고 저장 장치가 많이 소요되는 것이 단점
      - 현대 컴파일러의 성능으로 훨씬 쉽게 복잡한 의존성의 상세 사항들을 처리할 수 있음



## 운영체제 구조

- 현대 운영체제처럼 크고 복잡한 시스템은 적절하게 동작하고 쉽게 변경될 수 있으려면 신중히 제작되어야 함
  - 한 개의 일관된 시스템보다는 태스크를 작은 구성요소로 분할하는 것
- 종류
  - 모놀리식 구조
    - 커널의 모든 기능을 단일 주소 공간에서 실행되는 단일 정적 이진 파일에 넣는 것
      - 운영체제를 설계하는 일반적인 기술
    - 커널은 시스템 콜을 통해 파일 시스템, CPU 스케줄링, 메모리 관리, 다른 운영체제 기능을 제공
      - 하나의 주소 공간으로 결합하기에는 엄청나게 많은 기능을 가짐
      - 밀접하게 결합된 시스템으로 구현 및 확장하기 어려운 구조
    - 시스템 콜 인터페이스에 오버헤드가 거의 없고 커널 안에서의 통신 속도가 빠름
  - 계층적 접근
    - 특정 기능 및 한정된 기능을 가진 개별적이고 작은 구성 요소로 나뉘는 시스템
      - 느슨하게 결합된 시스템
    - 한 구성 요소의 변경이 해당 구성 요소에만 영향을 미치고 다른 구성 요소에는 영향을 미치지 않음
      - 시스템의 내부 작동을 더 자유롭게 생성하고 변경할 수 있음
    - 시스템을 계층으로 나누면 시스템의 설계나 구현, 디버깅이 간단해짐
    - 각 계층의 기능을 적절히 정의해야 하므로 순수한 계층 접근 방식을 사용하는 운영체제는 비교적 적음
      - 운영체제 서비스를 얻기 위해 사용자 프로그램이 여러 계층을 통과해야 하는 오버헤드 발생
    - 현대 운영체제에서는 더 많은 기능을 가진 더 적은 층을 통해 구현
      - 층 기능의 정의 및 상호 작용의 문제를 피하면서 모듈화된 코드의 장점을 활용할 수 있음
  - 마이크로 커널
    - 모든 중요하지 않은 구성 요소를 별도의 주소 공간에 존재하는 사용자 수준 프로그램으로 구현
      - 통신 설비 외의 추가로 최소한의 프로세스와 메모리 관리를 제공
    - 주로 클라이언트 프로그램과 사용자 공간에서 수행되는 다양한 서비스 간 통신을 제공
      - 클라이언트 프로그램과 서비스는 마이크로 커널을 통해 간접적으로 상호 작용함
    - 커널을 변경할 필요 없이 사용자 공간에 새로운 서비스가 추가되어 운영체제의 확장이 쉬움
      - 사용자 프로세스로 서비스가 수행되므로 보안성과 신뢰성이 높음
    - 커널이 작으므로 변경할 대상이 비교적 적고 다른 하드웨어로의 이식이 쉬움
    - 가중된 시스템 기능 오버헤드로 성능이 저하됨
    - 별도의 주소 공간에 서비스가 존재하므로 두 서비스 간 통신의 경우 메시지가 복사되어야 함
    - 메시지 교환을 위해 다른 프로세스로 전환되어야 할 수 있음
  - 모듈
    - 커널은 핵심 서비스만 제공하고 다른 서비스들은 커널이 실행되는 동안 동적으로 구현하는 것
      - 새로운 서비스를 모듈을 통해 동적으로 링크
      - 서비스 수정 사항이 생기더라도 커널을 다시 컴파일할 필요가 없음
    - 모듈에서 임의의 다른 모듈을 호출할 수 있어 계층 구조보다 유연함
    - 모듈 간 통신을 위해 메시지 전달을 호출할 필요가 없어 마이크로 커널 구조보다 더 효율적
  - 하이브리드 시스템
    - 대부분의 운영체제는 다양한 구조를 결합하여 성능, 보안 및 편리성 문제를 해결하려는 혼용 구조로 구성



## 운영체제 빌딩과 부팅

- 일반적으로 운영체제는 다양한 주변장치 구성을 가진 모든 종류의 컴퓨터에서 실행되도록 설계
- 운영체제 생성
  - 운영체제 소스 코드 작성(수정)
  - 운영체제가 실행될 시스템의 운영체제 구성
  - 운영체제 컴파일(시스템 빌드)
  - 운영체제 설치
  - 컴퓨터와 새 운영체제 부팅
- 시스템 부트
  - 운영체제 생성 후 하드웨어에서 새 운영체제를 사용할 수 있어야 함
  - 부팅 과정
    - 부트스트랩 프로그램 또는 부트 로더라는 작은 코드가 커널의 위치를 찾음
      - BIOS, UEFI, LK 등
    - 커널이 메모리에 적재되고 시작
    - 커널이 하드웨어를 초기화
    - 루트 파일 시스템이 마운트됨
  - 대부분의 운영체제의 부트 로더는 복구 모드 또는 단일 사용자 모드로 부팅할 수 있는 기능 제공
    - 복구 모드에서는 하드웨어 문제 진단, 손상된 파일 시스템 복구 및 운영체제 재설치 등 지원



## 운영체제 디버깅

- 디버깅
  - 하드웨어와 소프트웨어에서의 시스템 오류를 발견하고 수정하는 행위
  - 성능 문제는 버그로 간주되므로 성능 조정도 디버깅에 포함됨
    - 성능 조정은 시스템 처리 중에 발생하는 병목 현상을 제거하여 성능을 향상하도록 함
- 장애 분석
  - 대부분의 운영체제에서 프로세스 실패 시 오류 정보를 로그 파일에 기록
    - 프로세스가 사용하던 메모리를 캡처한 코어 덤프를 취하고 파일로 저장
    - 이후 디버거에 의해 검사될 수 있고 장애 발생 시 프로그래머가 코드와 메모리를 분석할 수 있도록 함
  - 커널 장애는 크래시라 불리며 장애 발생 시 크래시 덤프에 저장
  - 파일 시스템 코드로 발생한 커널 장애에서 재부팅 전에 커널 상태를 파일 시스템에 저장하는 것은 위험
    - 커널의 메모리 상태를 이 용도를 위해 예약된 파일 시스템을 갖지 않은 디스크의 특정 부분에 저장
    - 시스템 재부팅 시 프로세스가 해당 영역으로부터 데이터를 수집해 크래시 덤프 파일에 기록
- 성능 관찰 및 조정
  - 성능 조정을 위한 병목 지점을 발견하기 위해 시스템 성능을 감시할 수 있음
  - 카운터
    - 호출된 시스템 콜 횟수나 네트워크 장치 또는 디스크에 수행된 작업 수와 같은 시스템 활동 추적
    - 카운터 기반 도구는 커널에서 유지 관리하는 특정 통계의 현재 값을 간략히 제공
    - Windows 작업 관리자 등
- 추적
  - 추적 도구는 시스템 콜과 관련된 단계와 같은 특정 이벤트에 대한 데이터 수집