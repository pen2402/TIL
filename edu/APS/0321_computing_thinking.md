# 컴퓨팅 사고력

## 서론 - 프로그래밍과 논리/수학

- 일상 생활에서는 Soft Logic(직관)이 빠르기 때문에 유용
  - 논리적으로 부정확한 표현을 사용하지만, 어떤 의미인지 모든 사람이 이미 알고 있다는 가정 존재
- 프로그래밍은 Hard Logic을 사용
  - 프로그래밍 언어의 표현들이 모두 논리학에서 나온 것
  - 사용되는 수많은 알고리즘들을 이해하기 위해서는 Hard Logic 필요
- 오해의 근원
  - Soft Logic으로 알고리즘을 이해하려고 하는 것
  - 어려운 알고리즘을 직관으로 완전한 이해를 얻는 것은 사실상 불가능



## 논리와 증명

- 명제
  - 참이나 거짓을 알 수 있는 식이나 문장
  - p, q, r, ... 로 표현
- 진리값
  - 참이나 거짓을 표현
  - T, F 또는 1, 0
- 연산
  - 부정 NOT
    - p가 명제일 때,
  - 논리곱 AND
    - p, q가 명제일 때, p, q 모두 참일 때만 참이 되는 명제
    - p ^ q (p and q, p 그리고 q)
  - 논리합 OR
    - p, q가 명제일 때, p, q 모두 거짓일 때만 거짓이 되는 명제
    - p V q(p or q, p 또는 q)
  - 배타적 논리합 XOR
    - p, q가 명제일 때, p, q 중 하나만 참일 때 참이 되는 명제
    - p + q (p xor q)
  - 합성
    - 연산자 우선 순위
      - ㄱ > V, ^ > →, ↔
    - 항진명제 : 진리값이 항상 참
    - 모순명제 : 진리값이 항상 거짓
    - 사건명제 : 항진명제도 모순명제도 아닌 명제
  - 조건명제
    - p, q가 명제일 때, 명제 p가 조건(또는 원인), q가 결론(또는 결과)로 제시되는 명제
    - p → q(p이면 q이다)
    - 조건이 거짓이면 결과와 상관 없이 조건명제는 참
  - 쌍방조건명제
    - p, q가 명제일 때, 명제 p와 q가 모두 조건이면서 결론인 명제
    - p ↔ q(p면 q이고, q면 p이다)
  - 조건명제의 역, 이, 대우
    - 역 : q → p
      - 조건과 결과를 뒤집은 것
    - 이 : ㄱp → ㄱq
      - 조건과 결과를 모두 부정한 것
    - 대우 : ㄱq → ㄱp
      - 조건과 결과를 뒤집은 것을 모두 부정한 것
    - 조건명제와 대우의 결과가 동일하고, 역과 이의 결과가 동일
- 증명
  - 정확한 명제식으로 표현할 수 있는 것이라야 함
  - 보통은 정확한 명제식까지 쓰지는 않으나 근본적으로는 명제식으로 바꿀 수 있음
  - 증명에 대한 수많은 오해가 p->q를 p<->와
- 수학적 귀납법과 증명의 수준
  - 수학적 귀납법의 기본형 : P(1)이 참이고, P(n) → P(n+1)이 참이면 P(n)은
- 



## 2. 수와 표현

- 컴퓨터는 0/1을 표현할 수 있는 비트들을 모아 수를 표현
- k개의 비트를 사용하면 0부터 2^k-1까지 표현 가능
- 2^k >= n+1
- k >= log (n+1)
- x = log n과 2^x = n과 같은 말
  - 컴퓨터 분야에서 로그의 밑은 항상 2
- 



## 3. 집합과 조합

- 귀류법 : 현명제
- 명제의 부정을 참이라 가정하고 이의 모순을 증명하여 원래의 명제가 참임을 보임
- 문제 4 : A-B는 A의 부분집합이므로 모순



## 4. 기초 수식

- 점근적 상한 n log n



## 5. 재귀

- 재귀란 자기 자신을 호출하는 함수
- 함수는 입력이 있으며, 자기 자신의 입력과 동일한 입력으로 자기 자신을 호출하면
- 함수란 어떤 문제를 해결하는 방법을 코딩하는 것



## 6. 동적 프로그래밍

- 재귀 함수에서 동일한 입력의 함수 호출이 반복적으로 일어날 때 그 결과 값을 저장해 두고 불러 쓰는 것
- 최초 입력에서 파생되는 모든 가능한 입력에 대한 답을 모두 저장할 수 있는 메모리가 있어야 함
- 단순히 재귀에서 저장된 값을 차장보는 것으로도 가능하지만,
- 
