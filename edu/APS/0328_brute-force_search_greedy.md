# 완전 검색 & 그리디

## 반복과 재귀

- 반복은 수행하는 작업이 완료될 때까지 계속 반복
  
- 재귀는 주어진 문제의 해를 구하기 위해 동일하면서 더 작은 문제의 해를 이용하는 방법
  
- 반복구조
  
  - 초기화
    - 반복되는 명령문을 실행하기 전에 조건 검사에 사용할 변수의 초기값 설정
  - 조건 검사
  - 반복할 명령문 실행
  - 업데이트
    - 무한 루프가 되지 않게 조건이 거짓이 되게 함
  
- 재귀 함수(recursive function)

  - 함수 내부에서 직접 혹은 간접적으로 자기 자신(구조가 동일한)을 호출하는 함수

- 재귀는 문제 해결을 위한 알고리즘 설계가 간단하고 자연스러움

  - 추상 자료형(리스트, 트리 등)의 알고리즘은 재귀적 구현이 간단하고 자연스러운 경우가 많음

- 일반적으로 재귀적 알고리즘은 반복 알고리즘보다 더 많은 메모리와 연산을 필요로 함

- 입력 값이 커질 수록 재귀 알고리즘은 반복에 비해 비효율적일 수 있음

  |                | 재귀                                    | 반복                  |
  | -------------- | --------------------------------------- | --------------------- |
  | 종료           | 재귀 함수 호출이 종료되는 베이스 케이스 | 반복문의 종료 조건    |
  | 수행 시간      | 상대적으로 느림                         | 빠름                  |
  | 메모리 공간    | 상대적으로 많이 사용                    | 적게 사용             |
  | 소스 코드 길이 | 짧고 간결                               | 긺                    |
  | 소스 코드 형태 | 선택 구조(if else)                      | 반복 구조(for, while) |
  | 무한 반복 시   | 스택 오버플로우                         | CPU를 반복해서 점유   |



## 완전 검색 기법

- 고지식한 방법(brute-force)
  - 자료들의 리스트에서 키 값을 찾기 위해 첫 번째 자료부터 비교하면서 진행
  - 모든 경우의 수를 생성하고 테스트하기 때문에 수행 속도는 느리지만 해답을 찾아내지 못할 확률이 작음
  - 이를 기반으로 그리디 기법이나 동적 계획법을 이용해서 효율적인 알고리즘을 찾을 수 있음
  - 완전 검색으로 접근하여 해답 도출한  후 성능 개선 위해 다른 알고리즘 적용하고 확인하는 것이 바람직
- 완전 검색
  - 완전 검색은 조합적 문제에 대한 brute-force 방법
- 순열(Permutation)
  - 서로 다른 n개의 원소 중 r개를 뽑아서 한 줄로 나열하는 것(순서)
  - 최소 변경을 통한 방법(Minimum-change requirement)
    - 각각의 순열들은 이전 상태에서 두 요소의 자리 교환을 통해 생성
- 부분 집합
  - 집합에 포함된 원소들을 선택하는 것
  - N개의 원소를 포함한 집합
    - 자기 자신과 공집합 포함한 모든 부분 집합(power set)의 개수는 2^n개
    - 원소의 수가 증가하면 부분 집합의 개수는 지수적으로 증가
  - 바이너리 카운팅(Binary Counting)
    - 원소 수에 해당하는 N개의 비트열 이용
    - n번째 비트 값이 1이면 n번째 원소가 포함되었음을 의미
    - 부분집합을 생성하기 위한 가장 자연스러운 방법
    - 사전적 순서(Lexicographic Order)로 생성하기 위한 가장 간단한 방법
- 조합(combination)
  - 서로 다른 n개의 원소 중 r개를 순서 없이 골라낸 것



## 탐욕(Greedy) 알고리즘

- 최적해를 구하는 데 사용되는 근시안적인 방법

  - 그 순간에 최적이라고 생각되는 것을 선택해나가는 방식으로 최종적인 해답에 도달
  - 한번 선택된 것은 번복하지 않음
  - 지역적으로는 최적이나 최종적인 해답이 최적이라는 보장은 없음
  - 최적화 문제(optimization)란 가능한 해들 중 가장 좋은(최대 또는 최소) 해를 찾는 문제

- 동작 과정

  1. 해 선택
     - 부분 문제의 최적 해를 부분해 집합에 추가

  2. 실행 가능성 검사
     - 새로운 부분 해 집합이 실행 가능한지(제약 조건 위반 여부) 확인

  3. 해 검사
     - 새로운 부분 해 집합이 문제의 해가 되는지 확인
     - 전체 문제의 해가 완성되지 않았다면 1번 과정부터 다시 반복

- 탐욕 알고리즘의 필수 요소

  - 탐욕적 선택 속성(greedy choice property)
    - 탐욕적 선택은 최적해로 갈 수 있음(항상 안전함)을 증명
  - 최적 부분 구조(optimal substructure property)
    - 최적화 문제를 정형화

- 탐욕 알고리즘과 동적 계획법

  | 탐욕 알고리즘               | 동적계획법                 |
  | --------------------------- | -------------------------- |
  | 지역 최적 선택              | 해결한 하위 문제의 해 기반 |
  | 탐욕적 선택이 먼저 이루어짐 | 하위 문제가 우선 해결      |
  | Top-down                    | Bottom-up                  |
  | 일반적으로 빠르고 간결      | 느리고 복잡                |

  
