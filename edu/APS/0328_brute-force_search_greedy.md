# 완전 검색 & 그리디

## 반복과 재귀

- 반복구조
  - 초기화
    - 반복되는 명령문을 실행하기 전에 한번만 조건 검사에 사용할 변수의 초기값 설정
  - 조건 검사
  - 반복할 명령문 실행
  - 업데이트
    - 무한 루프가 되지 않게 조건이 거짓이 되게 함

- 재귀 함수

  - 함수 내부에서 직접 혹은 간접적으로

- 재귀는 문제 해결을 위한 알고리즘 설계가 간단하고 자연스러움

  - 추상 자료형의 알고리즘은 재귀적 구현이 간단하고 자연스러운 경우가 많음

- 일반적으로 재귀적 알고리즘은 반복 알고리즘보다 더 많은 메모리와 연산을 필요로 함

- 입력 값이 커질 수록 재귀 알고리즘은 반복에 비해 비효율적일 수 있음

- |                | 재귀                                    | 반복                |
  | -------------- | --------------------------------------- | ------------------- |
  | 종료           | 재귀 함수 호출이 종료되는 베이스 케이스 | 반복문의 종료 조건  |
  | 수행 시간      | 상대적으로 느림                         |                     |
  | 메모리 공간    | 상대적으로 많이 사용                    | 적게 사용           |
  | 소스 코드 길이 | 짧고 간결                               | 긺                  |
  | 소스 코드 형태 | 선택 구조                               | 반복 구조           |
  | 무한 반복 시   | 스택 오버플로우                         | CPU를 반복해서 점유 |



## 완전 검색 기법

- 고지식한 방법(brute-force)
  - 자료들의 리스트에서 키 값을 찾기 위해 첫 번째 자료부터 비교하면서 진행
  - 모든 경우의 수를 생성하고 테스트하기 때문에 수행 속도는 느리지만 해답을 찾아내지 못할 확률이 작음
  - 이를 기반으로 그리디 기법이나 동적 계획법을 이용해서 효율적인 알고리즘을 찾을 수 있음
- 완전 검색
  - 완전 검색은 조합적 문제에 대한 brute-force 방법
- 순열(permutation)
  - 서로 다른 n개의 원소 중 r개를 뽑아서 한 줄로 나열하는 것(순서)

- 바이너리 카운팅을 통한 사전적 순서(Lexicographic Order)
  - 부분집합을 생성하기 위한 가장 자연스러운 방법
  - 바이너리 카운팅(Binary Counting)은 사전적 순서로 생성하기 위한 가장 간단한 방법
- 바이너리 카운팅(Binary Counting)
  - 원소 수에 해당하는 N개의 비트열 이용
  - n번째 비트 값이 1이면 n번째 원소가 포함되었음을 의미
- 조합(combination)
  - 서로 다른 n개의 원소 중 r개를 순서 없이 골라낸 것



## 탐욕(Greedy) 알고리즘

- 최적해를 구하는 데 사용되는 근시안적인 방법
- 한번 선택된 것은 번복하지 않음
- 최적화 문제(optimization)란 가능한 해들 중 가장 좋은(최대 또는 최소) 해를 찾는 문제
- 배낭 짐싸기(knapsack)
  - 
